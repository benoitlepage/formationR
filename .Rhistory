xor(5 < 10), (2 != 5)
xor((5 < 10), (2 != 5))
(5 < 10)
(2 != 5)
xor((5 > 10), (2 != 5))
xor((5 > 10), (2 == 5))
xor(TRUE, TRUE)
xor(TRUE, FALSE)
xor(FALSE, TRUE)
xor(FALSE, FALSE)
xor((5 < 10), (2 != 5)) # (TRUE) OU exclusif (TRUE) donne FALSE
xor((5 > 10), (2 != 5)) # (FALSE) OU exclusif (TRUE) donne TRUE
xor((2 != 5), (5 > 10)) # (TRUE) OU exclusif (FALSE) donne TRUE
xor((5 > 10), (2 == 5)) # (FALSE) OU exclusif (FALSE) donne FALSE
is.numeric(5L)
is.integer(4.95)
is.numeric("bonjour")
is.character("bonjour")
is.character(4.95)
is.logical(1)
is.logical(TRUE)
is.integer(4.95)
"azer"
is.numeric(5L) # TRUE, un entier est bien un objet numérique
is.integer(4.95) # FALSE, 4.95 n'est pas un entier
is.numeric("bonjour") # FALSE "bonjour" est une chaîne de caractères
is.character("bonjour") # TRUE, "bonjour" est bien une chaîne de caractères
is.character(4.95) # FALSE, 4.95 est un objet numérique
is.logical(1) # FALSE, 1 est un objet numérique
is.logical(as.logical(1)) # TRUE, as.logical(1) = TRUE, qui est un objet logique
is.logical(TRUE) # TRUE est bien un objet logique
is.identical(5, 10)
identical(5, 10)
identical(c(1,2,3), c(1,2,3))
as.list(c(1,2,3))
as.list(c(1,2,3),c(4,5,6),c(7,8,9))
x_1 <- 1:5
x_2 <- 1:9
list(x1,x2)
list(x_1,x_2)
list(x_1,x2)
data(iris)
View(data(iris))
df <- data(iris)
df
data("iris")
risi
iris
data("BOD")
BOD
df <- data(sleep)
df
data(sleep)
sleep
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T, FALSE, TRUE)
print(vect_logic)
vect_num <- c(1, pi, 3.54)
vect_num
# Un vecteur de 3 nombres réels
vect_num <- c(1, pi, 3.54)
print(vect_num)
# Un vecteur de 5 entiers
vect_int <- c(5L, 4)
# Un vecteur de 6 chaînes de caractères
vect_char <- c("a", "B", "XYZ", "HELLO", "HOMME", "femme")
# Un vecteur logique
# pour les valeurs logiques, on peut utiliser les abbréviations T pour TRUE,
# et F pour FALSE
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T, FALSE, TRUE)
print(vect_logic)
class(vect_num)
class(vect_int)
class(vect_char)
class(vect_logic)
vect_new <- c(vect_num, vect_int)
print(vect_new)
vect_num <- c(1, pi, 3.54)
print(vect_num)
# Un vecteur de 5 entiers
vect_int <- c(5L, 4L, -3L, 15L, -8L)
vect_new <- c(vect_num, vect_int)
print(vect_new)
# Un vecteur de 3 nombres réels
vect_num <- c(1, pi, 3.54)
print(vect_num)
# Un vecteur de 5 entiers
vect_int <- c(5L, 4L, -3L, 15L, -8L)
# Si on combine ces 2 vecteurs, on obtient un vecteur de 8 nombres réels
vect_new <- c(vect_num, vect_int)
print(vect_new)
# 1.000000  3.141593  3.540000  5.000000  4.000000 -3.000000 15.000000 -8.000000
# Un vecteur de 6 chaînes de caractères
vect_char <- c("a", "B", "XYZ", "HELLO", "HOMME", "femme")
# Un vecteur logique
# pour les valeurs logiques, on peut utiliser les abbréviations T pour TRUE,
# et F pour FALSE
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T, FALSE, TRUE)
print(vect_logic)
# la fonction class() permet de décrire le type du vecteur
class(vect_num) # numeric
class(vect_int) # numeric
class(vect_char) # character
class(vect_logic) # logical
length(vect_num) # numeric
length(vect_int) # numeric
length(vect_new) # numeric
length(vect_char) # character
length(vect_logic) # logical
vect_melange <- c(1,2,"trois",4)
# les valeurs numériques seront transformées de force en caractères
print(vect_melange)
c(5L, 4L, -3L, 15L, -8L)
class(vect_new) # numeric
class(vect_int)
?seq()
vect_1a10 <- 1:10 # vecteur ascendant
vect_5_a_moins5 <- 5:-5 # vecteur descendant
print(vect_1a10)
vect_5_a_moins5 <- 5:-5 # vecteur descendant
print(vect_5_a_moins5)
vect_3_a_moins5 <- 3:-5 # vecteur descendant
print(vect_3_a_moins5)
?rep
rep(1:4, times = 3)
rep(1:4, times = 3)
rep(1:4, each = 3)
rep(1:4, length.out = 10)
rep(5, times = 3)
seq(from = 1, to = 10, by = 2)
seq(from = 1, to = 50, by = 2, length.out = 15)
seq(from = 1, to = 50, length.out = 5)
seq(from = 0, to = 50, length.out = 5)
seq(from = 1, to = 50, length.with = c("un","deux","trois"))
seq(from = 1, to = 50, along.with = c("un","deux","trois"))
seq(from = 1, to = 50, along.with = c("dix","vingt","trente"))
seq(from = 1, to = 3, by = 0.5)
seq(from = 1, to = 3, by = 1/3)
seq(from = 1, to = 4, by = 1/3)
seq(from = 1, to = 4, by = 2/3)
seq(from = 0, to = 10, by = 3.5)
seq(from = 0, to = 10, by = 2.5)
seq(from = 1, to = 10, by = 1.5)
seq(from = 0, to = 10, by = 1.5)
vect_int <- c(5L, 4L, -3L, 15L, -8L)
print(vect_int)
vect_num <- c(1, pi, 3.54)
print(vect_num)
vect_char <- c("a", "B", "XYZ", "HELLO", "HOMME", "femme")
vect_char
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T, FALSE, TRUE)
print(vect_logic)
# Un vecteur de 3 nombres réels
vect_num <- c(1, pi, 3.54)
print(vect_num) # [1] 1.000000 3.141593 3.540000
# Un vecteur de 5 entiers
vect_int <- c(5L, 4L, -3L, 15L, -8L)
print(vect_int) # [1]  5  4 -3 15 -8
# Si on combine ces 2 vecteurs, on obtient un vecteur de 8 nombres réels
# (les nombres entiers sont automatiquement transformés en nombres réels pour
# qu'ils soient  tous du même type)
vect_new <- c(vect_num, vect_int)
print(vect_new)
# 1.000000  3.141593  3.540000  5.000000  4.000000 -3.000000 15.000000 -8.000000
# Un vecteur de 6 chaînes de caractères
vect_char <- c("a", "B", "XYZ", "HELLO", "HOMME", "femme")
vect_char # [1] "a"     "B"     "XYZ"   "HELLO" "HOMME" "femme"
# Un vecteur logique
# pour les valeurs logiques, on peut utiliser les abbréviations T pour TRUE,
# et F pour FALSE
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T, FALSE, TRUE)
print(vect_logic) # [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE
# la fonction class() permet de décrire le type du vecteur
class(vect_num) # numeric
class(vect_int) # vect_int
class(vect_new) # numeric
class(vect_char) # character
class(vect_logic) # logical
# Si vous créez le vecteur suivant en mélangeant valeurs numériques et
# chaînes de caractères
vect_melange <- c(1,2,"trois",4)
# les valeurs numériques sont transformées de force en chaînes de caractères
# c("X","X",...,"X","X") pour que toutes les valeurs soient du même type.
print(vect_melange)
# [1] "1"     "2"     "trois" "4"
length(vect_num) # 3
length(vect_int) # 5
length(vect_new) # 8
length(vect_char) # 6
length(vect_logic) # 8
seq(from = 0, to = 10, by = 2)
seq(from = 0, to = 60, along.with = c("dix","vingt","trente"))
seq(from = 1, to = 50, length.out = 5)
seq(from = 1, to = 10, by = 2)
paste0("L",seq(from = 1, to = 10))
# additionne +2 à la séquence c(1,2,3,4,5)
seq(from = 1, to = 5) + 2
# soustrait -2 à la séquence c(1,2,3,4,5)
seq(from = 1, to = 5) - 2
# multiplie par 5 la séquence c(1,2,3,4,5)
seq(from = 1, to = 5) * 5
# divise par 5 la séquence c(1,2,3,4,5)
seq(from = 1, to = 5) / 5
vec_A <- 1:5
vec_B <- c(-1, +1, -2, +2, -3)
vec_A + vec_B
vec_A <- c(1, 2, 3, 4, 5)
vec_B <- c(-1, +1, -2, +2, -5)
vec_A + vec_B
vec_A - vec_B
vec_A * vec_B
vec_A - vec_B
vec_A / vec_B
vec_A + vec_C
vec_A <- c(1, 2, 3, 4, 5)
vec_C <- c(1, 2, 3)
# addition : c(1 + 1, 2 + 2, 3 + 3, 4 + 1, 5 + 2)
vec_A + vec_C
vec_A - vec_C
vec_A * vec_C
vec_A / vec_C
vec_A <- c(1, 2, 3, 4, 5, 6)
vec_C <- c(1, 2, 3)
vec_A + vec_C
rep(1:4, length.out = 10)
vec_A <- c(1, 2, 3, 4, 5)
vec_B <- c(-1, +1, -2, +2, -5)
vec_A + vec_B
vec_A - vec_B
vec_A * vec_B
vec_A * vec_B
vec_A / vec_B
vec_A <- c(1, 2, 3, 4, 5)
vec_C <- c(1, 2, 3)
vec_A + vec_C
vec_A - vec_C
vec_A * vec_C
vec_A / vec_C
names(vec_A)
paste0("L",seq(from = 1, to = 10))
paste0(c("A","B","C"), seq(from = 1, to = 10))
5 %in% c(4,5,6)
5 %in% c(7,8,9)
c(1, 2, 3) %in% seq(from = 1, to = 9, by = 2)
seq(from = 1, to = 9, by = 2)
seq(from = 1, to = 9, by = 2) %in% c(1, 2, 3)
c(TRUE, TRUE, FALSE, FALSE) & c(TRUE, FALSE, TRUE, FALSE)
c(TRUE, TRUE, FALSE, FALSE) | c(TRUE, FALSE, TRUE, FALSE)
c(TRUE, TRUE, FALSE, FALSE) && c(TRUE, FALSE, TRUE, FALSE)
?ordered()
var <- c(0, 2, 0, 0, 1, 2, 1, 0, 0, 2, 1, 2, 0, 1)
var.quali <- as.factor(var)
var.quali
class(var.quali)
attr(var.quali)
attributes(var.quali)
print(var.quali)
as.factor(c(-1,-2,0,1,-1))
var.quali <- factor(var_1)
rm(var)
rm(var.quali)
var_1 <- c(0, 2, 0, 0, 1, 2, 1, 0, 0, 2, 1, 2, 0, 1, 1)
var.quali <- factor(var_1)
var.quali <- as.factor(var_1)
var_1 <- c(0, 2, 0, 0, 1, 2, 1, 0, 0, 2, 1, 2, 0, 1, 1)
var.quali <- as.factor(var_1)  # autre possibilité : var.quali <- factor(var_1)
print(var.quali)
class(var.quali)
is.factor(var_1) # FALSE, la variable "var_1" est un vecteur numérique
is.factor(var.quali)
attributes(var.quali)
class(attributes(var.quali))
vec_ON <- c(0,0,1,0,1)
names(vec_ON) <- c("non","non","oui","non","oui")
names(vec_ON)
rm(list=ls())
var_1 <- c(0, 2, 0, 0, 1, 2, 1, 0, 0, 2, 1, 2, 0, 1, 1)
var_quali <- as.factor(var_1)
print(var_quali)
class(var_quali)
var_quali <- as.factor(var_1)  # autre possibilité : var.quali <- factor(var_1)
print(var_quali)
class(var_quali)
is.factor(var_1) # FALSE, l'objet "var_1" est un vecteur numérique
is.factor(var_quali)
attr_var_quali <- attributes(var_quali)
attr_var_quali <- attributes(var_quali)
1+1
attr_var_quali <- attributes(var_quali)
class(attr_var_quali)
print(attr_var_quali)
attr_var_quali$levels
attr_var_quali$class
class(attr_var_quali$levels)
attr_var_quali$levels
length(var_quali)
class(attr_var_quali$levels)
attr_var_quali$class
?factor
var_1 <- c(0, 2, 0, 0, 1, 2, NA, 0, NA, 2, 1, 2, 0, 1, 1)
var_quali <- factor(var_1,
levels = c("0","1","2"),
labels = c("non","oui","ne sait pas")
)
var_quali
is.factor(var_quali)
is.ordered(var_quali)
attr_var_quali <- attributes(var_quali)
attr_var_quali
new_var_quali <- as.numeric(var_quali)
new_var_quali <- as.numeric(var_quali)
new_var_quali
satisf <- c(1,4,2,3,1,3,2,5,4,5,3,2,3)
# on associe des noms aux valeurs 1,2,3,4,5
names(satisf) <- c("non","plutôt","un peu","moyen","non","moyen","un peu",
"très","plutôt","très,moyen","un peu","moyen")
var_quali
addNA(var_quali, ifany = TRUE)
satisf <- c(1,4,2,3,1,3,2,5,4,5,3,2,3)
# on associe des noms aux valeurs 1,2,3,4,5
names(satisf) <- c("non","plutôt","un peu","moyen","non","moyen","un peu",
"très","plutôt","très,moyen","un peu","moyen")
satisf
typeof(1:10)
?POSIXct
?difftime
typeof(ISOdate(2001, 4, 26) - ISOdate(2001, 2, 26))
is.double(5L)
typeof(2.53) # un réel
typeof(5L)
mode(2.53) # sont de type 'numeric'
mode(5L)
is.atomic(list())
is.atomic(x = 1)
is.atomic(list(1))
?c()
?list()
?list
?matrix
1 / 0
-1 / 0
log(-1)
round(0.09400, digits = 2)
round(0.08600, digits = 2)
round(4.450, digits = 1)
round(4.750, digits = 1)
round(4.5, digits = 0) # arrondit à l'entier pair le plus proche
round(1.5, digits = 0)
signif(123.456789, digits = 1)
signif(123.456789, digits = 2)
signif(123.456789, digits = 3)
signif(123.456789, digits = 4)
signif(123.456789, digits = 5)
signif(4.45, digits = 3)
signif(4.45, digits = 2)
signif(4.75, digits = 3)
signif(4.75, digits = 2)
trunc(123.456)
trunc(4.5)
trunc(1.5)
? trunc
floor(4.1)
floor(4.9)
ceiling(4.1)
ceiling(4.9)
vect_dbl <- c(1, pi, 3.54)
print(vect_dbl) # [1] 1.000000 3.141593 3.540000
vect_int <- c(5L, 4L, -3L, 15L, -8L)
print(vect_int) # [1]  5  4 -3 15 -8
vect_char <- c("a", "B", "XYZ", "HELLO", "HOMME", "femme")
vect_char # [1] "a"     "B"     "XYZ"   "HELLO" "HOMME" "femme"
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T, FALSE, TRUE)
print(vect_logic) # [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE
vect1 <- c(vect_dbl, vect_int, vect_char, vect_logic)
vect1
vect2 <- c(vect_dbl, vect_int,  vect_logic)
vect2
vect3 <- c(vect_int,  vect_logic)
vect3
typeof(vect1)
typeof(vect2)
typeof(vect3)
vect1 <- c(1, 2, 3)
vect2 <- c(4, 5, 6)
vect3 <- c(7, 8, 9)
vect_combine <- c(vect1, vect2, vect3)
vect_combine
class(vect_num) # numeric
# Un vecteur de 3 nombres réels
vect_dbl <- c(1, pi, 3.54)
print(vect_dbl) # [1] 1.000000 3.141593 3.540000
# Un vecteur de 5 entiers
vect_int <- c(5L, 4L, -3L, 15L, -8L)
print(vect_int) # [1]  5  4 -3 15 -8
# Un vecteur de 4 chaînes de caractères
vect_char <- c("a", "B", "XYZ", "HELLO")
vect_char # [1] "a"     "B"     "XYZ"   "HELLO"
# Un vecteur logique
# pour les valeurs logiques, on peut utiliser les abbréviations T pour TRUE,
# et F pour FALSE
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T)
print(vect_logic) # [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE
rm(list=ls())
# Un vecteur de 3 nombres réels
vect_dbl <- c(1, pi, 3.54)
print(vect_dbl) # [1] 1.000000 3.141593 3.540000
# Un vecteur de 5 entiers
vect_int <- c(5L, 4L, -3L, 15L, -8L)
print(vect_int) # [1]  5  4 -3 15 -8
# Un vecteur de 4 chaînes de caractères
vect_char <- c("a", "B", "XYZ", "HELLO")
vect_char # [1] "a"     "B"     "XYZ"   "HELLO"
# Un vecteur logique
# pour les valeurs logiques, on peut utiliser les abbréviations T pour TRUE,
# et F pour FALSE
vect_logic <- c(TRUE, FALSE, FALSE, F, T, T)
print(vect_logic) # [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE
vect1 <- c(1, 2, 3)
vect2 <- c(4, 5, 6)
vect3 <- c(7, 8, 9)
vect_combine <- c(vect1, vect2, vect3)
vect_combine
# [1] 1 2 3 4 5 6 7 8 9
vect_1a10 <- 1:10 # vecteur ascendant
vect_1a10 # [1]  1  2  3  4  5  6  7  8  9 10
vect_3_a_moins5 <- 3:-5 # vecteur descendant
vect_3_a_moins5 # [1] 3  2  1  0 -1 -2 -3 -4 -5
seq(from = 1, to = 10) # vecteur de 1 à 10, équivalent à la commande 1:10
seq(from = 0, to = 10, by = 2) # vecteur de 0 à 10, de 2 en 2
seq(from = 1, to = 50, length.out = 5) # vecteur de 1 à 50, de longueur 5
# les intervalles entre les valeurs sont calculés automatiquement par la formule
# (valeur de départ - valeur d'arrivée) / (longueur totale - 1)
seq(from = 0, to = 60, along.with = c("dix", "vingt", "trente"))
# vecteur de 0 à 60, dont la longueur est égale à la longeur du vecteur
# c("dix","vingt","trente") (sa longeur est de 3)
# avec l'argument 'by', si le cycle ne tombe pas juste, la séquence s'arrête
# avant la dernière valeur indiquée par 'to = '
seq(from = 1, to = 10, by = 2)
# [1] 1 3 5 7 9
# la séquence ne va pas jusqu'à 10, elle s'arrête à 9, car 9 + 2 = 11
# ce qui dépasserait la valeur maximale demandée par 'to = 10'
rep(5, times = 3) # répète la valeur 5, 3 fois.
# [1] 5 5 5
rep(1:4, times = 3) # repète 3 fois le vecteur c(1, 2, 3, 4)
# [1] 1 2 3 4 1 2 3 4 1 2 3 4
rep(1:4, each = 3) # chaque élément du vecteur c(1, 2, 3, 4) est répété 3 fois
# [1] 1 1 1 2 2 2 3 3 3 4 4 4
rep(1:4, length.out = 10) # le vecteur c(1,2,3,4) est répété dans un vecteur
# dont la longueur totale est de 10
# [1] 1 2 3 4 1 2 3 4 1 2
# On vérifie ce principe de coercition
vect1 <- c(vect_dbl, vect_int, vect_char, vect_logic)
vect1
typeof(vect1) # "character"
vect2 <- c(vect_dbl, vect_int,  vect_logic)
vect2
typeof(vect2) # "double"
vect3 <- c(vect_int,  vect_logic)
vect3
typeof(vect3) # "integer"
vect_num
class(vect_dbl) # numeric
class(vect_int) # vect_int
class(vect_new) # numeric
class(vect_dbl) # numeric
class(vect_int) # vect_int
class(vect_char) # character
class(vect_logic) # logical
length(vect_dbl) # numeric   # note ici, il indique "numeric" plutôt que "double"
length(vect_int) # integer
length(vect_char) # character
length(vect_logic) # logical
attributes(vect_dbl)
structure(vect_dbl)
str(vect_dbl)
str(vect_dbl) # 3
str(vect_int) # 5
str(vect_char) # 4
str(vect_logic) # 6
sex <- c(1, 1, 2, 1, 2, 2)
typeof(sex)
names(sex) <- c("homme", "homme", "femme", "homme", "femme", "femme")
sex
str(sex)
vect_bizarre <- c(1, 2, 3, 4, 5)
names(vect_bizarre) <- c("un", "trois", "douze", "douze", "2")
vect_bizarre
attr(sex)
sex
attr(sex, names)
attr(sex, names)
attributes(sex)
attr(sex, "names")
attr(sex, "long_name") <- c("Sexe du participant")
sex
attributes(sex)
attr(sex, "var_name") <- c("Sexe du participant")
sex
sex <- c(1, 1, 2, 1, 2, 2)
names(sex) <- c("homme", "homme", "femme", "homme", "femme", "femme")
sex
vect_bizarre <- c(1, 2, 3, 4, 5)
names(vect_bizarre) <- c("un", "trois", "douze", "douze", "2")
vect_bizarre
attr(sex, "names")
# [1] "homme" "homme" "femme" "homme" "femme" "femme"
# cette fonction permet également de définir de nouveux attributs
# par exemple, si on veut ajouter un nom de variable détaillé comme attribut
attr(sex, "var_name") <- c("Sexe du participant")
sex
attributes(sex)
attributes(sex)$names
attributes(sex)$var_name
