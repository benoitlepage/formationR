meta_df_1 <- read.csv2("data/meta_df_1.csv")
meta_df_1
#      var               label id_labs code_labs         labs
# 1 subjid Identifiant patient       1        NA
# 2    sex                Sexe       1         0      Féminin
# 3    sex                Sexe       2         1     Masculin
# 4    imc         IMC (kg/m²)       1        NA
# 5  trait          Traitement       1         1      Placebo
# 6  trait          Traitement       2         2 Traitement A
# 7  trait          Traitement       3         3 Traitement B
# 8    pas          PAS (mmHg)       1        NA
# ---------------------------------------------------------------------------- #
# 2) Jeter un oeil à la base de données ----
# ---------------------------------------------------------------------------- #
head(df_1)
#   subjid sex  imc trait pas
# 1      1   0 24.8     2 140
# 2      2   0 24.1     3 109
# 3      3   0 26.4     1 156
# 4      4   0 23.3     2 124
# 5      5   0 25.4     2 131
# 6      6   1 25.0     3 148
tail(df_1)
#     subjid sex  imc trait pas
# 295    295   1 24.1     1 148
# 296    296   0 18.7     3 121
# 297    297   0 23.3     3 111
# 298    298   1 27.5     3 134
# 299    299   1 24.7     2 158
# 300    300   1 22.8     1 147
View(df_1)
str(df_1)
# 'data.frame':	300 obs. of  6 variables:
# $ X     : int  1 2 3 4 5 6 7 8 9 10 ...
# $ subjid: int  1 2 3 4 5 6 7 8 9 10 ...
# $ sex   : int  0 0 0 0 0 1 0 0 0 0 ...
# $ imc   : num  24.8 24.1 26.4 23.3 25.4 25 25.2 21.5 21.8 25.9 ...
# $ trait : int  2 3 1 2 2 3 3 3 1 1 ...
# $ pas   : int  140 109 156 124 131 148 125 117 132 133 ...
# ---------------------------------------------------------------------------- #
## 2.1) créer une nouvelle variable imc en classes ----
# ---------------------------------------------------------------------------- #
df_1$obesite <- ifelse(df_1$imc >= 30, 1, 0)
min(df_1$imc[dif_1$obesite == 0])
min(df_1$imc[df_1$obesite == 0])
max(df_1$imc[df_1$obesite == 0])
min(df_1$imc[df_1$obesite == 1])
max(df_1$imc[df_1$obesite == 1])
df_1$imc_cl <- rep(NA, nrow(df_1))
df_1$imc_cl[df_1$imc < 18.5] <- 1
df_1$imc_cl[df_1$imc >= 18.5 & df_1$imc < 25] <- 2
df_1$imc_cl[df_1$imc >= 25 & df_1$imc < 30] <- 3
df_1$imc_cl[df_1$imc >= 30] <- 4
boxplot(df_1$imc ~ df_1$imc_cl)
head(df_1)
head(df_1[,-c("imc_cl")])
head(df_1[,-c(imc_cl)])
names(df_1)
head(df_1[,-c(7)])
df_1 <- df_1[,-c(7)]
df_1$imc_cl <- ifelse(df_1$imc < 18.5, 1,
ifelse(df_1$imc >= 18.5 & df_1$imc < 25, 2),
ifelse(df_1$imc >= 25 & df_1$imc < 30, 3, 4))
df_1$imc_cl <- ifelse(df_1$imc < 18.5, 1,
ifelse(df_1$imc >= 18.5 & df_1$imc < 25,
2, ifelse(df_1$imc >= 25 & df_1$imc < 30, 3, 4)))
boxplot(df_1$imc ~ df_1$imc_cl) # ok pas de chevauchement
df_1$imc_cl <- (1 * (df_1$imc < 18.5) +
2 * (df_1$imc >= 18.5 & df_1$imc < 25) +
3 * (df_1$imc >= 25 & df_1$imc < 30) +
4 * (df_1$imc >= 30))
boxplot(df_1$imc ~ df_1$imc_cl) # ok pas de chevauchement
df_2 <- df_1 # on créer une base df_2, comme un double de la baes df_1
head(df_2)
df_2$pas[df_2$subjid == 137]
df_2$pas[df_2$subjid == 137] <- 123
df_2$pas[df_2$subjid == 137]
df_2[df_2$subjid %in% 130:137,]
df_2[df_2$subjid %in% 130:140,]
df_2[df_2$subjid %in% 135:140,]
sessionInfo()
environmentName()
globalenv()
getwd()
?read.csv2
df_1 <- read.csv2("data/df_1.csv")
classe(df_1)
df_1 <- read.csv2("data/df_1.csv")
class(df_1)
View(df_1)
sessionInfo()
sessionInfo()
df_1 <- read.csv2("data/df_1.csv")
meta_df_1 <- read.csv2("data/meta_df_1.csv")
df_1$obesite <- ifelse(df_1$imc >= 30, 1, 0)
min(df_1$imc[df_1$obesite == 0])
max(df_1$imc[df_1$obesite == 0])
min(df_1$imc[df_1$obesite == 1])
max(df_1$imc[df_1$obesite == 1])
names(df_1)
dim(df_1)
rm(list=ls())
df <- data.frame(id = c(1:10),
age = c(42.5, 27.9, 60, 74.5, 38, 25.2, 53.4, 46.6, 34.2, 39.6),
sex = c("M", "F", "F", "M", "M", "F", "M", "F", "F", "M"),
dt_vis = c("2025-12-08", "2025-02-04", "2022-04-22",
"2023-10-29", "2023-01-31", "2024-12-17",
"2025-09-13", "2025-11-07", "2022-04-25",
"2023-08-02"))
df
df[-c(2,5), -c(1,3)]
df[-c("2", "5"), -c("id", "sex")]
df[-c(2:5), -c(1,3)]
rm(list = ls()) # cette commande vide le contenu de l'environnement
df_1 <- read.csv2("data/df_1.csv")
meta_df_1 <- read.csv2("data/meta_df_1.csv")
df_1$obesite <- ifelse(df_1$imc >= 30, 1, 0)
df_1$imc_cl <- ifelse(df_1$imc < 18.5, 1,
ifelse(df_1$imc >= 18.5 & df_1$imc < 25,
2, ifelse(df_1$imc >= 25 & df_1$imc < 30, 3, 4)))
meta_df_1
c(rep("obesite", 2),
rep("imc_cl", 4))
c(1:2, 1:4)
meta_df_1 <- rbind(meta_df_1,
data.frame(var == c(rep("obesite", 2),
rep("imc_cl", 4)),
label == c(rep("Obésité", 2),
rep("IMC en classes", 4)),
id_labs = c(1:2, 1:4),
code_labs = c(0:1, 1:4),
labs = c("Non", "Oui",
"Maigreur", "Normal", "Surpoids", "Obèse"))
)
data.frame(var == c(rep("obesite", 2),
rep("imc_cl", 4)),
label == c(rep("Obésité", 2),
rep("IMC en classes", 4)),
id_labs = c(1:2, 1:4),
code_labs = c(0:1, 1:4),
labs = c("Non", "Oui",
"Maigreur", "Normal", "Surpoids", "Obèse"))
data.frame(var = c(rep("obesite", 2),
rep("imc_cl", 4)),
label = c(rep("Obésité", 2),
rep("IMC en classes", 4)),
id_labs = c(1:2, 1:4),
code_labs = c(0:1, 1:4),
labs = c("Non", "Oui",
"Maigreur", "Normal", "Surpoids", "Obèse"))
df_1$pas[df_1$subjid == 137] # la PAS de ce patient est bien 133 mmHg
## nous pouvons directement assigner la nouvelle valeur avec l'indexation par
## condition :
df_1$pas[df_1$subjid == 137] <- 123
df_1[df_1$subjid %in% 135:140,]
# on voit que la valeur du patient 137 a bien été corrigée
summary(df_1)
df_1$sexL <- factor(df_1$sex,
labels = meta_df_1$labs[meta_df_1$var == "sex"])
df_1$traitL <- factor(df_1$trait,
labels = meta_df_1$labs[meta_df_1$var == "trait"])
summary(df_1)
nrow(df_1)
length(df_1$imc)
### Pour compter les effectifs non-manquants, de manière explicite :
length(df_1$imc[!is.na(df_1$imc)])
mean(df_1$imc, na.rm = TRUE) # 24.481
mean(df_1$pas, na.rm = TRUE) # 137.1467
sd(df_1$imc, na.rm = TRUE) # 3.069072
sd(df_1$pas, na.rm = TRUE) # 16.80237
var(df_1$imc, na.rm = TRUE) # 3.069072
var(df_1$pas, na.rm = TRUE) # 16.80237
min(df_1$imc, na.rm = TRUE) # 15.4
min(df_1$pas, na.rm = TRUE) # 92
max(df_1$imc, na.rm = TRUE) # 32.5
max(df_1$pas, na.rm = TRUE) # 177
median(df_1$imc, na.rm = TRUE)
median(df_1$pas, na.rm = TRUE) # 177
quantile(df_1$imc, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)
quantile(df_1$pas, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)
density(df_1$imc, xlab = "IMC (kg/m²)", main = "Histogramme de l'IMC")
df_1 <- read.csv2("data/df_1.csv")
meta_df_1 <- read.csv2("data/meta_df_1.csv")
df_1$obesite <- ifelse(df_1$imc >= 30, 1, 0)
df_1$imc_cl <- rep(NA, nrow(df_1))
###    puis remplacer les données manquantes par les valeurs souhaitées
df_1$imc_cl[df_1$imc < 18.5] <- 1
df_1$imc_cl[df_1$imc >= 18.5 & df_1$imc < 25] <- 2
df_1$imc_cl[df_1$imc >= 25 & df_1$imc < 30] <- 3
df_1$imc_cl[df_1$imc >= 30] <- 4
meta_df_1 <- rbind(meta_df_1,
data.frame(var = c(rep("obesite", 2),
rep("imc_cl", 4)),
label = c(rep("Obésité", 2),
rep("IMC en classes", 4)),
id_labs = c(1:2, 1:4),
code_labs = c(0:1, 1:4),
labs = c("Non", "Oui",
"Maigreur", "Normal", "Surpoids", "Obèse"))
)
meta_df_1
df_1$pas[df_1$subjid == 137] <- 123
df_1[df_1$subjid %in% 135:140,]
df_1$sexL <- factor(df_1$sex,
labels = meta_df_1$labs[meta_df_1$var == "sex"])
df_1$traitL <- factor(df_1$trait,
labels = meta_df_1$labs[meta_df_1$var == "trait"])
summary(df_1)
### Définir une nouvelle fonction dans R
univ_quanti <- function(x, # la variable à décrire
dig = 2, # par défaut, 2 chiffres après la virgule
remove_miss = TRUE # par défaut, la valeur est TRUE
) { # fermez la parenthèse et ouvrez l'accolade
# on commence par calculer les différents paramètres et on les stocke dans
# les objets : "n", "moy", "sd" et "q"
n <- length(x[!is.na(x)])
moy <- mean(x, na.rm = remove_miss)
sd <- sd(x, na.rm = remove_miss)
q <- quantile(x, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = remove_miss)
# on stocke les résultats dans un vecteur de réels, nommé "param",
# en gardant uniquement la valeur arrondie pour la moyenne et l'écart-type
param <- c(n,
round(moy, digits = dig),
round(sd, digits = dig),
q)
# on peut ajouter un nom à chaque élément du vecteur "param"
names(param) <- c("N", "mean", "sd", "min", "Q1", "median", "Q3", "max")
# indiquer ce que doit retourner la fonction
return(param)
} # fermez l'accolade
names(df_1)
for (i in c(3, 5)) {
print(names(df_1)[i]) # imprime le nom de la i-ème variable
# puis imprime les résultats de la fonction univ_quanti appliquée à la i-ème
# variable de la base df_1
print(univ_quanti(df_1[[i]], dig = 1, remove_miss = TRUE))
}
hist(df_1$imc, xlab = "IMC (kg/m²)", main = "Histogramme de l'IMC")
hist(df_1$pas, xlab = "PAS (mmHg)", main = "Histogramme de la PAS")
par(mfrow(c(1, 2))) # indiquer c(X, Y) ou X = nb de lignes et Y = nb de colonnes
par(mfrow = c(1, 2)) # indiquer c(X, Y) ou X = nb de lignes et Y = nb de colonnes
density(df_1$imc, xlab = "IMC (kg/m²)", main = "Histogramme de l'IMC")
density(df_1$pas, xlab = "PAS (mmHg)", main = "Histogramme de la PAS")
plot(density(df_1$imc, xlab = "IMC (kg/m²)", main = "Histogramme de l'IMC"))
plot(density(df_1$imc), xlab = "IMC (kg/m²)", main = "Histogramme de l'IMC")
plot(density(df_1$pas), xlab = "PAS (mmHg)", main = "Histogramme de la PAS")
plot(density(df_1$pas), xlab = "PAS (mmHg)", main = "Histogramme de la PAS")
plot(density(df_1$imc), xlab = "IMC (kg/m²)", main = "Histogramme de l'IMC")
plot(density(df_1$pas), xlab = "PAS (mmHg)", main = "Histogramme de la PAS")
tapply(X = df_1[,c("imc")],
INDEX = list(df_1$sexL),
FUN = univ_quanti, # fonction à utiliser
dig = 1, remove_miss = TRUE, details = FALSE)
univ_quanti <- function(x, dig = 2, remove_miss = TRUE, details = TRUE) {
n <- length(x[!is.na(x)])
moy <- mean(x, na.rm = remove_miss)
sd <- sd(x, na.rm = remove_miss)
q <- quantile(x, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = remove_miss)
# construction if (condition) {expression1} else {expression2}
if (details == TRUE) { # si la condition entre parenthèse est vraie ...
param <- c(n,        # ... appliquer les fonctions entre accolades
round(moy, digits = dig),
round(sd, digits = dig),
q)
} else { # sinon appliquer les fonctions entre la 2ème accolade
param <- c(n,
round(moy, digits = dig),
round(sd, digits = dig))
}
# ajouter un nom à chaque élément du vecteur
if (details == TRUE) {
names(param) <- c("N", "mean", "sd", "min", "Q1", "median", "Q3", "max")
} else {
names(param) <- c("N", "mean", "sd")
}
# retourne les résultats
return(param)
}
aggregate(x = df_1[,c("pas")],
by = list(df_1$sexL),
FUN = univ_quanti, # fonction à utiliser
dig = 1, remove_miss = TRUE, details = FALSE)
aggregate(x = df_1[,c("pas")],
by = list(df_1$traitL),
FUN = univ_quanti, # fonction à utiliser
dig = 1, remove_miss = TRUE, details = FALSE)
tapply(X = df_1[,c("imc")],
INDEX = list(df_1$sexL),
FUN = univ_quanti, # fonction à utiliser
dig = 1, remove_miss = TRUE, details = FALSE)
tapply(X = df_1[,c("imc")],
INDEX = list(df_1$sexL, df_1$traitL),
FUN = univ_quanti, # fonction à utiliser
dig = 1, remove_miss = TRUE, details = FALSE)
tapply(X = df_1$imc,
INDEX = list(df_1$traitL), # facteur à indiquer sous forme de liste.
FUN = univ_quanti, # fonction à utiliser
dig = 1, remove_miss = TRUE, details = FALSE)
sex_by_trait_N <- table(df_1$sexL, df_1$traitL)
sex_by_trait_N
prop.table(sex_by_trait_N, margin = 1)
prop.table(sex_by_trait_N, margin = 2)
prop.table(sex_by_trait_N, margin = c(1,2))
proportions(sex_by_trait_N)
prop.table(sex_by_trait_N)
prop.table(sex_by_trait_N, margin = NULL)
?car
??car
car::leveneTest(data = df_1, imc ~ sexL)
ttest_pas_sex <- t.test(data = df_1, imc ~ sex,
var.equal = TRUE) # replacer FALSE par TRUE
# pour obtenir le test de Student
ttest_pas_sex
ttest_pas_sex <- t.test(data = df_1, # préciser quelle est la base de donnée
pas ~ sexL, # moyenne de la PAS en fonction du sexe
var.equal = TRUE)
ttest_pas_sex
??car
carHexsticker()
plot(carHexsticker())
car::leveneTest(data = df_1, pas ~ sexL)
car::leveneTest(data = df_1, pas ~ sexL)
plot(density(df_1$pas ~ df_1$sexL))
plot(density(df_1$pas))
class(plot(density(df_1$pas)))
head(as.character(df_1$sexL))
head(as.integer(df_1$sexL))
line(density(df_1$pas))
par(mfrow = c(1, 1))
line(density(df_1$pas))
density(df_1$pas)
class(density(df_1$pas))
par(mfrow = c(1, 2)) # les 2 figures seront présentées sur 1 ligne
for (i in 1:2) {
plot(density(df_1$pas[as.integer(df_1$sexL) == i]))
curve(dnorm(seq(min(df_1$pas[as.integer(df_1$sexL) == i]),
max(df_1$pas[as.integer(df_1$sexL) == i]),
length(50)),
mean = mean(df_1$pas[as.integer(df_1$sexL) == i]),
sd = sd(df_1$pas[as.integer(df_1$sexL) == i])))
}
plot(density(df_1$pas[as.integer(df_1$sexL) == i]),
main = "titre")
par(mfrow = c(1, 2)) # les 2 figures seront présentées sur 1 ligne
for (i in 1:2) {
plot(density(df_1$pas[as.integer(df_1$sexL) == i]),
main = "titre")
# la fonction suivante ajoute une loi normale en pointillés rouges,
# de même moyenne et de même écart-type, pour servir de référence
line(dnorm(seq(min(df_1$pas[as.integer(df_1$sexL) == i]),
max(df_1$pas[as.integer(df_1$sexL) == i]),
length(50)),
mean = mean(df_1$pas[as.integer(df_1$sexL) == i]),
sd = sd(df_1$pas[as.integer(df_1$sexL) == i])))
}
par(mfrow = c(1, 2)) # les 2 figures seront présentées sur 1 ligne
for (i in 1:2) {
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = "titre")
# la fonction suivante ajoute une loi normale en pointillés rouges,
# de même moyenne et de même écart-type, pour servir de référence
lines(x = seq(min(vect), max(vect), length(50)),
y = dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)),
col = "red", lty = 2)
}
rm(vect) # supprime l'objet x qui n'est plus utile
par(mfrow = c(1, 1))
i = 1
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = "titre")
attributes(df_1$sexL)
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
seq(min(vect), max(vect), length(50))
dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect))
length(dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)))
length(seq(min(vect), max(vect), length(50)))
lines(x = seq(min(vect), max(vect), length(50)),
y = dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)),
col = "red", lty = "dashed")
mean(vect)
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect))
max(dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)))
par(mfrow = c(1, 2)) # les 2 figures seront présentées sur 1 ligne
for (i in 1:2) {
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
# la fonction suivante ajoute une loi normale en pointillés rouges,
# de même moyenne et de même écart-type, pour servir de référence
lines(x = seq(min(vect), max(vect), length(50)),
y = dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)),
col = "red", lty = "dashed")
}
rm(vect) # supprime l'objet x qui n'est plus utile
par(mfrow = c(1, 2)) # les 2 figures seront présentées sur 1 ligne
for (i in 1:2) {
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
# la fonction suivante ajoute une loi normale en pointillés rouges,
# de même moyenne et de même écart-type, pour servir de référence
# lines(x = seq(min(vect), max(vect), length(50)),
#       y = dnorm(seq(min(vect), max(vect), length(50)),
#                 mean = mean(vect),
#                 sd = sd(vect)),
#       col = "red", lty = "dashed")
}
rm(vect) # supprime l'objet x qui n'est plus utile
i = 1
seq(min(vect), max(vect), length(50))
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
seq(min(vect), max(vect), length(50))
par(mfrow = c(1, 1))
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
lines(x = seq(min(vect), max(vect), length(50)),
y = dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)),
col = "red", lty = "dashed")
par(mfrow = c(1, 2)) # les 2 figures seront présentées sur 1 ligne
for (i in 1:2) {
vect <- df_1$pas[as.integer(df_1$sexL) == i]
plot(density(vect),
main = attributes(df_1$sexL)$levels[i])
lines(x = seq(min(vect), max(vect), length(50)),
y = dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)),
col = "red", lty = "dashed")
}
rm(vect) # supprime l'objet x qui n'est plus utile
wilcox.test(data = df_1, pas ~ sex) # p-value = 1.529e-06
mod_pas_trait <- lm(pas ~ traitL, # modèle de PAS en fonction du traitement
data = df_1)
# le fait d'utiliser un "factor" (traitL) comme variable explicative
# va permettre à R de créer automatiquement deux indicatrices pour modéliser
# le traitement à 3 catégorie, en prenant la première catégorie ("placebo")
# comme référence
summary(mod_pas_trait)
anova(mod_pas_trait)
anova_pas_trait <- anova(mod_pas_trait)
anova_pas_trait
anova_pas_trait$`Pr(>F)`
car::leveneTest(data = df_1, pas ~ traitL)
qqplot(mod_pas_trait$residuals)
head(mod_pas_trait$residuals)
qqnorm(mod_pas_trait$residuals)
qqline(mod_pas_trait$residuals)
vect <- mod_pas_trait$residuals
plot(density(vect), # densité de kernel
main = "Residuals")
lines(x = seq(min(vect), max(vect), length(50)), # loi normale de référence
y = dnorm(seq(min(vect), max(vect), length(50)),
mean = mean(vect),
sd = sd(vect)),
col = "red", lty = "dashed")
rm(vect)
kruskal.test(pas ~ traitL, data = df_1) # p-value = 6.33e-05
chi2 <- chisq.test(table(df_1$sexL, df_1$traitL),
correct = FALSE)
chi2
model <- lm(pas ~ traitL + sexL + imc,
data = df_1)
summary(model)
scatter.smooth(model$fitted.values, model$residuals,
lpars =list(col = "red", lwd = 0.5, lty = 1),
xlab = "Valeurs prédites", ylab = "Résidus")
abline(h = 0, lwd = 0.5, lty = 2)
par(mfrow = c(1, 1)) # 1 figure sur 1 ligne et 1 colonne
# la fonction suivant trace une courbe lissée (loess)
# au milieu d'un nuage de points
scatter.smooth(model$fitted.values, model$residuals,
lpars = list(col = "red", lwd = 0.5, lty = 1),
xlab = "Valeurs prédites", ylab = "Résidus")
abline(h = 0, # ajoute une ligne horizontale en 0
lwd = 0.5, # largeur de ligne (line width)
lty = 2) # type de ligne = pointillé
plot(model)
cor(df_1$imc, df_1$pas, method = "pearson")
cor <- cor(df_1$imc, df_1$pas, method = "pearson")
cor.test(df_1$imc, df_1$pas, method = "pearson")
rho_spearm <- cor.test(df_1$imc, df_1$pas, method = "spearman")
rho_spearm
rho_pearson
rho_pearson <- cor.test(df_1$imc, df_1$pas, method = "pearson")
rho_pearson
rho_spearm <- cor.test(df_1$imc, df_1$pas, method = "spearman")
rho_spearm
